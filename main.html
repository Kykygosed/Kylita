<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Voice chat par fréquence - WebRTC + Firebase</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; background: #222; color: #eee; }
  input, button { font-size: 1em; padding: 8px; margin: 5px; }
  #log { background: #111; height: 150px; overflow-y: auto; padding: 10px; margin-top: 10px; border-radius: 5px; }
</style>
</head>
<body>

<h2>Entrer la fréquence pour chatter</h2>
<input id="freq" placeholder="Exemple: 12380" />
<button id="joinBtn">Rejoindre</button>

<div id="status"></div>
<button id="leaveBtn" style="display:none;">Quitter la fréquence</button>

<div id="log"></div>

<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

<script>
  // Config Firebase
  const firebaseConfig = {
    apiKey: "AIzaSyDyWu4TI4PIRXfeb7yqt0WIGClgu10IjkM",
    authDomain: "kylita-f2923.firebaseapp.com",
    databaseURL: "https://kylita-f2923-default-rtdb.firebaseio.com",
    projectId: "kylita-f2923",
    storageBucket: "kylita-f2923.firebasestorage.app",
    messagingSenderId: "431823530994",
    appId: "1:431823530994:web:88a07e633751686e5ad96b",
    measurementId: "G-F4LLNWQJ16"
  };
  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // UI
  const freqInput = document.getElementById('freq');
  const joinBtn = document.getElementById('joinBtn');
  const leaveBtn = document.getElementById('leaveBtn');
  const statusDiv = document.getElementById('status');
  const logDiv = document.getElementById('log');

  function log(msg) {
    console.log(msg);
    logDiv.textContent += msg + '\n';
    logDiv.scrollTop = logDiv.scrollHeight;
  }

  // Variables WebRTC
  let localStream = null;
  let peerConnection = null;
  let freqRef = null;
  let isCaller = false;
  let remoteDescriptionSet = false;
  let pendingCandidates = [];

  // Config ICE servers publiques Google
  const iceServers = {
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
  };

  joinBtn.onclick = async () => {
    const freq = freqInput.value.trim();
    if (!freq) {
      alert('Merci d’entrer une fréquence valide (ex: 12380)');
      return;
    }
    joinBtn.disabled = true;
    freqInput.disabled = true;
    leaveBtn.style.display = 'inline-block';
    statusDiv.textContent = `Connexion à la fréquence ${freq}...`;

    // Nettoyer les caractères invalides pour Firebase keys (pas de . # $ [ ] dans la key)
    const freqKey = freq.replace(/[.#$[\]]/g, "_");
    freqRef = db.ref('frequencies/' + freqKey);

    await startCall();
  };

  leaveBtn.onclick = async () => {
    statusDiv.textContent = 'Déconnecté';
    joinBtn.disabled = false;
    freqInput.disabled = false;
    leaveBtn.style.display = 'none';

    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }
    if (localStream) {
      localStream.getTracks().forEach(t => t.stop());
      localStream = null;
    }
    if (freqRef) {
      await freqRef.remove();
      freqRef = null;
    }
    remoteDescriptionSet = false;
    pendingCandidates = [];
    log('Déconnexion effectuée.');
  };

  async function startCall() {
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
      log('Micro activé');

      peerConnection = new RTCPeerConnection(iceServers);

      // Ajout des tracks audio au peerConnection
      localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

      // Quand on reçoit un track, on le joue
      peerConnection.ontrack = event => {
        log('Flux audio reçu');
        const remoteAudio = document.getElementById('remoteAudio');
        if (!remoteAudio) {
          const audioElem = document.createElement('audio');
          audioElem.id = 'remoteAudio';
          audioElem.autoplay = true;
          document.body.appendChild(audioElem);
          audioElem.srcObject = event.streams[0];
        } else {
          remoteAudio.srcObject = event.streams[0];
        }
      };

      peerConnection.onicecandidate = event => {
        if (event.candidate) {
          // Envoie ICE candidate à Firebase
          freqRef.child(isCaller ? 'callerCandidates' : 'calleeCandidates').push(event.candidate.toJSON());
          log('ICE candidate envoyée');
        }
      };

      // Observateurs Firebase

      // Offre
      freqRef.child('offer').on('value', async snapshot => {
        const offer = snapshot.val();
        if (!offer || isCaller) return;

        log('Offre reçue, création réponse...');
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
        remoteDescriptionSet = true;

        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);
        await freqRef.child('answer').set(answer); 

        log('Réponse envoyée.');

        // Ajout candidats en attente
        for (const c of pendingCandidates) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(c));
        }
        pendingCandidates = [];
      });

      // Réponse
      freqRef.child('answer').on('value', async snapshot => {
        const answer = snapshot.val();
        if (!answer || !isCaller) return;

        log('Réponse reçue');
        await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
        remoteDescriptionSet = true;

        // Ajout candidats en attente
        for (const c of pendingCandidates) {
          await peerConnection.addIceCandidate(new RTCIceCandidate(c));
        }
        pendingCandidates = [];
      });

      // Candidates caller
      freqRef.child('callerCandidates').on('child_added', async snapshot => {
        const candidate = snapshot.val();
        if (isCaller) return;
        if (!remoteDescriptionSet) {
          pendingCandidates.push(candidate);
          log('Candidate caller stockée (remoteDescription pas encore prête)');
        } else {
          try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            log('Candidate caller ajoutée');
          } catch (e) {
            log('Erreur ajout candidate caller: ' + e);
          }
        }
      });

      // Candidates callee
      freqRef.child('calleeCandidates').on('child_added', async snapshot => {
        const candidate = snapshot.val();
        if (!isCaller) return;
        if (!remoteDescriptionSet) {
          pendingCandidates.push(candidate);
          log('Candidate callee stockée (remoteDescription pas encore prête)');
        } else {
          try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            log('Candidate callee ajoutée');
          } catch (e) {
            log('Erreur ajout candidate callee: ' + e);
          }
        }
      });

      // Créer l’offre si on est le premier (appelant)
      const offerSnapshot = await freqRef.child('offer').get();
      if (!offerSnapshot.exists()) {
        isCaller = true;
        log('Tu es l’appelant, création de l’offre...');
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);
        await freqRef.child('offer').set(offer.toJSON());
        log('Offre envoyée, en attente de la réponse...');
      } else {
        isCaller = false;
        log('Tu es le receveur, attente de l’offre...');
      }

      statusDiv.textContent = 'Connecté à la fréquence ' + freqInput.value;
    } catch (err) {
      log('Erreur : ' + err);
      joinBtn.disabled = false;
      freqInput.disabled = false;
      leaveBtn.style.display = 'none';
    }
  }
</script>

</body>
</html>

