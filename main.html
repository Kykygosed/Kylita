<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Radio Fr√©quence</title>
  <style>
    body {
      margin: 0;
      background-color: #000;
      color: white;
      font-family: sans-serif;
    }
    #volumeBarContainer, #incomingBarContainer {
      position: fixed;
      top: 50%;
      transform: translateY(-50%);
      width: 20px;
      height: 200px;
      background-color: #333;
      border: 2px solid #777;
      border-radius: 10px;
      overflow: hidden;
    }
    #volumeBarContainer { left: 10px; }
    #incomingBarContainer { right: 10px; }
    #volumeBar, #incomingBar {
      width: 100%;
      height: 0%;
      transition: height 0.1s ease;
    }
    #volumeBar { background-color: lime; }
    #incomingBar { background-color: cyan; }
  </style>
</head>
<body>
  <div id="volumeBarContainer"><div id="volumeBar"></div></div>
  <div id="incomingBarContainer"><div id="incomingBar"></div></div>

  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-database-compat.js"></script>

  <script>
    // Config Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyDyWu4TI4PIRXfeb7yqt0WIGClgu10IjkM",
      authDomain: "kylita-f2923.firebaseapp.com",
      databaseURL: "https://kylita-f2923-default-rtdb.firebaseio.com",
      projectId: "kylita-f2923",
      storageBucket: "kylita-f2923.appspot.com",
      messagingSenderId: "431823530994",
      appId: "1:431823530994:web:88a07e633751686e5ad96b",
      measurementId: "G-F4LLNWQJ16"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    // R√©cup√®re le pseudo de l'utilisateur
    const pseudo = localStorage.getItem("pseudo") || "Anonyme";
    const frequency = "freq123";
    const myId = Math.random().toString(36).substring(2, 9);

    // WebRTC setup
    let localStream;
    const peers = {};
    const configuration = { iceServers: [{ urls: "stun:stun.l.google.com:19302" }] };

    // üîä Barre d√©cibels micro
    function monitorMic(stream) {
      const audioCtx = new AudioContext();
      const analyser = audioCtx.createAnalyser();
      const micSource = audioCtx.createMediaStreamSource(stream);
      micSource.connect(analyser);
      analyser.fftSize = 256;
      const dataArray = new Uint8Array(analyser.frequencyBinCount);

      function updateVolumeBar() {
        analyser.getByteFrequencyData(dataArray);
        let avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
        let percent = Math.min(100, (avg / 255) * 100);
        document.getElementById("volumeBar").style.height = percent + "%";
        requestAnimationFrame(updateVolumeBar);
      }
      updateVolumeBar();
    }

    // üîà Barre d√©cibels entrants
    function monitorIncomingAudio(stream) {
      const audioCtx = new AudioContext();
      const analyser = audioCtx.createAnalyser();
      const source = audioCtx.createMediaStreamSource(stream);
      source.connect(analyser);
      analyser.fftSize = 256;
      const dataArray = new Uint8Array(analyser.frequencyBinCount);

      function updateIncomingBar() {
        analyser.getByteFrequencyData(dataArray);
        let avg = dataArray.reduce((a, b) => a + b) / dataArray.length;
        let percent = Math.min(100, (avg / 255) * 100);
        document.getElementById("incomingBar").style.height = percent + "%";
        requestAnimationFrame(updateIncomingBar);
      }
      updateIncomingBar();
    }

    async function start() {
      // üî¥ Acc√®s micro
      localStream = await navigator.mediaDevices.getUserMedia({ audio: true });
      monitorMic(localStream);

      // Enregistre l'utilisateur dans la fr√©quence
      db.ref(`frequencies/${frequency}/${myId}`).set({
        pseudo,
        joinedAt: Date.now()
      });

      // Supprime √† la d√©connexion
      window.addEventListener("beforeunload", () => {
        db.ref(`frequencies/${frequency}/${myId}`).remove();
      });

      // ‚úÖ On √©coute les autres utilisateurs
      db.ref(`frequencies/${frequency}`).on("child_added", async (snap) => {
        const peerId = snap.key;
        if (peerId === myId || peers[peerId]) return;

        const pc = new RTCPeerConnection(configuration);
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        peers[peerId] = pc;

        pc.onicecandidate = e => {
          if (e.candidate) {
            db.ref(`signals/${frequency}/${peerId}/${myId}/candidates`).push(JSON.stringify(e.candidate));
          }
        };

        pc.ontrack = e => {
          const remoteStream = e.streams[0];
          const audio = new Audio();
          audio.srcObject = remoteStream;
          audio.play();
          monitorIncomingAudio(remoteStream);
        };

        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        db.ref(`signals/${frequency}/${peerId}/${myId}`).set({
          offer: JSON.stringify(offer),
          from: myId,
          pseudo
        });
      });

      // ‚úÖ Quand quelqu‚Äôun nous envoie une offre
      db.ref(`signals/${frequency}/${myId}`).on("child_added", async (snap) => {
        const peerId = snap.key;
        const data = snap.val();
        if (peers[peerId]) return;

        const pc = new RTCPeerConnection(configuration);
        localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
        peers[peerId] = pc;

        pc.onicecandidate = e => {
          if (e.candidate) {
            db.ref(`signals/${frequency}/${peerId}/${myId}/candidates`).push(JSON.stringify(e.candidate));
          }
        };

        pc.ontrack = e => {
          const remoteStream = e.streams[0];
          const audio = new Audio();
          audio.srcObject = remoteStream;
          audio.play();
          monitorIncomingAudio(remoteStream);
        };

        const remoteOffer = JSON.parse(data.offer);
        await pc.setRemoteDescription(new RTCSessionDescription(remoteOffer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        db.ref(`signals/${frequency}/${peerId}/${myId}`).update({
          answer: JSON.stringify(answer)
        });
      });

      // ‚úÖ R√©ception des candidats ICE
      db.ref(`signals/${frequency}/${myId}`).on("child_changed", async (snap) => {
        const peerId = snap.key;
        const data = snap.val();
        if (data.answer && peers[peerId]) {
          const answer = JSON.parse(data.answer);
          await peers[peerId].setRemoteDescription(new RTCSessionDescription(answer));
        }
      });

      db.ref(`signals/${frequency}/${myId}`).on("child_added", snap => {
        const peerId = snap.key;
        db.ref(`signals/${frequency}/${myId}/${peerId}/candidates`).on("child_added", csnap => {
          const candidate = new RTCIceCandidate(JSON.parse(csnap.val()));
          if (peers[peerId]) {
            peers[peerId].addIceCandidate(candidate).catch(console.error);
          }
        });
      });
    }

    start();
  </script>
</body>
</html>
