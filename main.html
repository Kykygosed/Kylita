<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Chat vocal fréquence</title>
<style>
  body {
    font-family: Arial, sans-serif;
    background: #121212;
    color: #eee;
    margin: 0; padding: 0;
    display: flex; flex-direction: column; align-items: center;
    height: 100vh;
    justify-content: center;
  }
  #login, #call {
    background: #222;
    padding: 20px;
    border-radius: 8px;
    width: 320px;
    text-align: center;
  }
  input, select, button {
    width: 100%;
    margin: 8px 0;
    padding: 10px;
    border-radius: 5px;
    border: none;
    font-size: 16px;
  }
  button {
    background: #3b82f6;
    color: white;
    cursor: pointer;
  }
  button:disabled {
    background: #555;
    cursor: not-allowed;
  }
  audio {
    margin-top: 20px;
    width: 100%;
  }
</style>
</head>
<body>

<div id="login">
  <h2>Rejoindre une fréquence</h2>
  <input type="text" id="freqInput" placeholder="Ex: 12380 (sans point)" />
  <select id="inputSelect"></select>
  <select id="outputSelect"></select>
  <button id="joinBtn">Rejoindre</button>
  <p id="status"></p>
</div>

<div id="call" style="display:none;">
  <h2>En communication sur <span id="currentFreq"></span></h2>
  <button id="leaveBtn">Quitter</button>
  <audio id="remoteAudio" autoplay></audio>
</div>

<!-- Firebase -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

<script>
  // --- CONFIG FIREBASE ---
  const firebaseConfig = {
    apiKey: "AIzaSyDyWu4TI4PIRXfeb7yqt0WIGClgu10IjkM",
    authDomain: "kylita-f2923.firebaseapp.com",
    databaseURL: "https://kylita-f2923-default-rtdb.firebaseio.com",
    projectId: "kylita-f2923",
    storageBucket: "kylita-f2923.firebasestorage.app",
    messagingSenderId: "431823530994",
    appId: "1:431823530994:web:88a07e633751686e5ad96b",
    measurementId: "G-F4LLNWQJ16"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();

  // --- GLOBALS ---
  let localStream = null;
  let peerConnection = null;
  let roomRef = null;
  let freq = null;

  // --- ICE servers (Google STUN) ---
  const iceConfig = {
    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
  };

  // Gestion périphériques
  const inputSelect = document.getElementById('inputSelect');
  const outputSelect = document.getElementById('outputSelect');
  const remoteAudio = document.getElementById('remoteAudio');

  async function enumerateDevices() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const audioInputs = devices.filter(d => d.kind === 'audioinput');
    const audioOutputs = devices.filter(d => d.kind === 'audiooutput');

    inputSelect.innerHTML = '';
    audioInputs.forEach(d => {
      const option = document.createElement('option');
      option.value = d.deviceId;
      option.text = d.label || `Microphone ${inputSelect.length + 1}`;
      inputSelect.appendChild(option);
    });

    outputSelect.innerHTML = '';
    audioOutputs.forEach(d => {
      const option = document.createElement('option');
      option.value = d.deviceId;
      option.text = d.label || `Haut-parleur ${outputSelect.length + 1}`;
      outputSelect.appendChild(option);
    });
  }

  // Appliquer la sortie audio choisie
  function setOutputDevice(deviceId) {
    if (typeof remoteAudio.sinkId !== 'undefined') {
      remoteAudio.setSinkId(deviceId).catch(e => {
        console.warn('Erreur setSinkId', e);
      });
    }
  }

  inputSelect.onchange = () => {
    startLocalStream();
  };
  outputSelect.onchange = () => {
    setOutputDevice(outputSelect.value);
  };

  async function startLocalStream() {
    if (localStream) {
      localStream.getTracks().forEach(t => t.stop());
    }
    try {
      localStream = await navigator.mediaDevices.getUserMedia({
        audio: { deviceId: inputSelect.value ? { exact: inputSelect.value } : undefined }
      });
    } catch (e) {
      alert('Impossible d\'accéder au microphone: ' + e.message);
      return;
    }
  }

  // --- SIGNALING (Firebase) ---

  // Nettoyer l'ancienne room si existante
  async function cleanup() {
    if (roomRef) {
      await roomRef.remove();
      roomRef = null;
    }
    if (peerConnection) {
      peerConnection.close();
      peerConnection = null;
    }
  }

  // Rejoindre une fréquence = créer/signer un canal
  async function joinFreq(f) {
    freq = f;
    document.getElementById('status').textContent = 'Connexion...';

    await cleanup();

    // On crée un chemin firebase sans caractère interdit (pas de point)
    const roomPath = 'frequencies/' + freq;
    roomRef = db.ref(roomPath);

    // Créer peer connection
    peerConnection = new RTCPeerConnection(iceConfig);

    // Ajouter tracks du micro local
    localStream.getTracks().forEach(track => {
      peerConnection.addTrack(track, localStream);
    });

    // Quand on reçoit un flux distant, on le met dans remoteAudio
    peerConnection.ontrack = event => {
      if (remoteAudio.srcObject !== event.streams[0]) {
        remoteAudio.srcObject = event.streams[0];
        console.log('Flux distant reçu');
      }
    };

    // Gérer candidats ICE envoyés à Firebase
    peerConnection.onicecandidate = event => {
      if (event.candidate) {
        roomRef.child('candidates/' + localId).push(event.candidate.toJSON());
      }
    };

    // Générer un ID local (random)
    localId = Math.floor(Math.random() * 1000000).toString();

    // Observer l’état de la room pour savoir si une offre existe
    roomRef.child('offer').once('value').then(async snapshot => {
      if (snapshot.exists()) {
        // Si offre déjà présente, on est "answerer"
        const offer = snapshot.val();
        await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

        const answer = await peerConnection.createAnswer();
        await peerConnection.setLocalDescription(answer);

        await roomRef.child('answer').set(answer);

        listenCandidates();
      } else {
        // Pas d'offre : on est "offerer"
        const offer = await peerConnection.createOffer();
        await peerConnection.setLocalDescription(offer);

        await roomRef.child('offer').set(offer);

        listenCandidates();
      }
    });

    // Écoute des candidats distants
    function listenCandidates() {
      roomRef.child('candidates').on('child_added', async snap => {
        const peerId = snap.key;
        if (peerId === localId) return; // Ignorer candidats locaux

        snap.ref.on('child_added', async candidateSnap => {
          const candidate = candidateSnap.val();
          try {
            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
            console.log('Candidat ajouté:', candidate);
          } catch(e) {
            console.warn('Erreur addIceCandidate', e);
          }
        });
      });
    }

    document.getElementById('status').textContent = 'Connecté sur ' + freq;
    document.getElementById('login').style.display = 'none';
    document.getElementById('call').style.display = 'block';
    document.getElementById('currentFreq').textContent = freq;

    setOutputDevice(outputSelect.value);
  }

  document.getElementById('joinBtn').onclick = async () => {
    const f = document.getElementById('freqInput').value.trim();
    if (!f.match(/^\d+$/)) {
      alert('Fréquence invalide (chiffres uniquement, ex: 12380)');
      return;
    }

    await startLocalStream();
    await joinFreq(f);
  };

  document.getElementById('leaveBtn').onclick = async () => {
    await cleanup();
    document.getElementById('login').style.display = 'block';
    document.getElementById('call').style.display = 'none';
    document.getElementById('status').textContent = '';
    remoteAudio.srcObject = null;
  };

  // Au démarrage, lister les périphériques
  enumerateDevices().then(() => {
    if (inputSelect.options.length > 0) inputSelect.selectedIndex = 0;
    if (outputSelect.options.length > 0) outputSelect.selectedIndex = 0;
  });

</script>

</body>
</html>
