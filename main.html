<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Radio Fr√©quence</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #111;
      color: white;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 20px;
    }

    h1 {
      margin-bottom: 10px;
    }

    select, input, button {
      margin: 5px;
      padding: 8px;
      font-size: 1em;
    }

    #controls {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    #status {
      margin-top: 20px;
      font-size: 0.9em;
      color: #0f0;
    }
  </style>
</head>
<body>
  <h1>üéôÔ∏è Fr√©quence Radio</h1>

  <div id="controls">
    <label>Fr√©quence (ex: 122.80):</label>
    <input type="text" id="frequencyInput" placeholder="122.80" />

    <label>Microphone:</label>
    <select id="micSelect"></select>

    <label>Haut-parleur:</label>
    <select id="speakerSelect"></select>

    <button id="joinBtn">Rejoindre la fr√©quence</button>
    <button id="leaveBtn" disabled>Quitter</button>
  </div>

  <div id="status">Statut: Non connect√©</div>

  <!-- Firebase & WebRTC -->
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-database-compat.js"></script>

  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyDyWu4TI4PIRXfeb7yqt0WIGClgu10IjkM",
      authDomain: "kylita-f2923.firebaseapp.com",
      databaseURL: "https://kylita-f2923-default-rtdb.firebaseio.com",
      projectId: "kylita-f2923",
      storageBucket: "kylita-f2923.appspot.com",
      messagingSenderId: "431823530994",
      appId: "1:431823530994:web:88a07e633751686e5ad96b",
      measurementId: "G-F4LLNWQJ16"
    };

    firebase.initializeApp(firebaseConfig);
    const db = firebase.database();

    const micSelect = document.getElementById('micSelect');
    const speakerSelect = document.getElementById('speakerSelect');
    const joinBtn = document.getElementById('joinBtn');
    const leaveBtn = document.getElementById('leaveBtn');
    const frequencyInput = document.getElementById('frequencyInput');
    const status = document.getElementById('status');

    let localStream;
    let connections = {};
    let userId = "user_" + Math.floor(Math.random() * 100000);
    let currentFrequency = null;

    async function getDevices() {
      const devices = await navigator.mediaDevices.enumerateDevices();
      micSelect.innerHTML = "";
      speakerSelect.innerHTML = "";

      devices.forEach(device => {
        const option = document.createElement("option");
        option.value = device.deviceId;
        option.text = device.label || `${device.kind} ${micSelect.length + 1}`;
        if (device.kind === "audioinput") micSelect.appendChild(option);
        if (device.kind === "audiooutput") speakerSelect.appendChild(option);
      });
    }

    async function startStream() {
      const constraints = {
        audio: {
          deviceId: micSelect.value ? { exact: micSelect.value } : undefined
        }
      };
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      for (const id in connections) {
        localStream.getTracks().forEach(track => connections[id].addTrack(track, localStream));
      }
    }

    function createPeerConnection(targetId) {
      const pc = new RTCPeerConnection();
      pc.onicecandidate = e => {
        if (e.candidate) {
          db.ref(`${currentFrequency}/candidates/${userId}/${targetId}`).push(e.candidate.toJSON());
        }
      };

      pc.ontrack = e => {
        const audio = new Audio();
        audio.srcObject = e.streams[0];
        audio.autoplay = true;

        const selectedDeviceId = speakerSelect.value;
        if ("setSinkId" in audio && selectedDeviceId) {
          audio.setSinkId(selectedDeviceId).catch(e => {
            console.warn("Impossible de rediriger vers le haut-parleur s√©lectionn√©:", e);
          });
        }
      };

      localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
      return pc;
    }

    async function joinFrequency() {
      currentFrequency = "freq_" + frequencyInput.value.replace(".", "_");
      status.textContent = `Statut: Connect√© √† ${frequencyInput.value}`;

      await startStream();

      db.ref(`${currentFrequency}/users/${userId}`).set(true);
      db.ref(`${currentFrequency}/users/${userId}`).onDisconnect().remove();

      db.ref(`${currentFrequency}/users`).on("child_added", async snap => {
        const otherId = snap.key;
        if (otherId === userId || connections[otherId]) return;

        const pc = createPeerConnection(otherId);
        connections[otherId] = pc;

        const offer = await pc.createOffer();
await pc.setLocalDescription(answer);
setTimeout(() => {
  db.ref(`${currentFrequency}/answers/${userId}/${callerId}`).set(pc.localDescription.toJSON());
}, 500);

      });

      db.ref(`${currentFrequency}/offers`).on("child_added", snap => {
        const callerId = snap.key;
        if (callerId === userId) return;

        db.ref(`${currentFrequency}/offers/${callerId}/${userId}`).once("value", async s => {
          if (!s.exists()) return;
          const pc = createPeerConnection(callerId);
          connections[callerId] = pc;

          await pc.setRemoteDescription(new RTCSessionDescription(s.val()));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(offer);
setTimeout(() => {
  db.ref(`${currentFrequency}/offers/${userId}/${otherId}`).set(pc.localDescription.toJSON());
}, 500); // d√©lai pour laisser le temps aux ICE candidates de se pr√©parer

        });
      });

      db.ref(`${currentFrequency}/answers`).on("child_added", snap => {
        const answererId = snap.key;
        if (answererId === userId) return;

        db.ref(`${currentFrequency}/answers/${answererId}/${userId}`).once("value", async s => {
          if (s.exists() && connections[answererId]) {
            await connections[answererId].setRemoteDescription(new RTCSessionDescription(s.val()));
          }
        });
      });

      db.ref(`${currentFrequency}/candidates`).on("child_added", snap => {
        const senderId = snap.key;
        if (senderId === userId) return;

        db.ref(`${currentFrequency}/candidates/${senderId}/${userId}`).on("child_added", s => {
          const candidate = new RTCIceCandidate(s.val());
          if (connections[senderId]) {
            connections[senderId].addIceCandidate(candidate);
          }
        });
      });

      joinBtn.disabled = true;
      leaveBtn.disabled = false;
    }

    async function leaveFrequency() {
      db.ref(`${currentFrequency}/users/${userId}`).remove();
      status.textContent = `Statut: D√©connect√©`;
      joinBtn.disabled = false;
      leaveBtn.disabled = true;

      Object.values(connections).forEach(pc => pc.close());
      connections = {};

      if (localStream) {
        localStream.getTracks().forEach(track => track.stop());
        localStream = null;
      }

      currentFrequency = null;
    }

    joinBtn.onclick = joinFrequency;
    leaveBtn.onclick = leaveFrequency;

    getDevices();
    navigator.mediaDevices.ondevicechange = getDevices;
  </script>
</body>
</html>

